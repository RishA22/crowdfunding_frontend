JavaScript: A programming language used to make websites interactive (e.g., buttons, forms).
Frontend: The part of the app that users see and interact with, like buttons and text on a website.
React: A tool (library) that helps build user interfaces with reusable components.
Vite: A tool that quickly sets up projects and provides a fast development experience.
Template: A starting structure for your project, so you don’t have to build everything from scratch.
Component: A piece of UI that React can render (e.g., a button or a page).
State: Data that can change over time, causing a component to re-render.
Props: Data passed to a component that can influence what it renders.
DOM: The structure of your webpage, which React manipulates when rendering.


Why Are Routes Important?
Navigation: Allows users to visit different parts of your app by typing URLs or clicking links.
Single-Page Applications (SPAs): In React, routes help create SPAs where navigation happens without reloading the page.
Dynamic Data: Routes let you display specific content based on URL parameters, like user profiles or product details.

Example in Action
Imagine a website with two pages:

Home Page (/)
About Page (/about)
When you navigate to:

/: The browser shows the HomePage.
/about: The browser shows the AboutPage.
This is all powered by routes.

-Parameters in .map():

Most common: (element, index).
Optional: (element, index, array).

-React Naming Conventions
React has specific naming styles to make your codebase organized and easily understandable:

Naming Style	Usage	Example

PascalCase	React components (capitalized to signify their importance)	NavBar.jsx, ProjectCard.jsx

kebab-case	Non-component files (utility functions, styles, data, etc.)	project-card.css, data.js

camelCase	Variables, functions, or helper methods	fetchData.js, renderList()

-Async functions 
let your program keep running while waiting for long tasks, like downloading files or requesting data.
With async and await, we can pause and wait for tasks to finish in a way that doesn't stop everything else.
Async functions help make programs more efficient, responsive, and user-friendly.

-NPM is a tool to install libraries (like Lodash) that contain functions (like _.capitalize()) to perform tasks (like capitalizing a word) without needing to know the details.

-Node.js lets you use JavaScript on the server, and NPM helps you add ready-made tools (libraries) to your Node.js project.

-JSX is a special syntax in React that allows you to write HTML-like code inside JavaScript, making it easier to build web pages and user interfaces

-A modern browser is a web browser that supports the latest web technologies, provides better security, and ensures websites and applications work well on any device.

-Code Editor: A lightweight tool to edit code.
-VS Code: A powerful, feature-rich code editor that’s also customizable with plugins and extensions.

-A Live Server Environment allows you to see changes in your website or app immediately, without having to manually refresh the page. It helps speed up development by providing real-time updates as you work on the code.

-A web server is a machine or software that serves the content of websites to users. It processes requests from users and sends back the website files so they can be displayed in a web browser.

-The browser console is a developer tool in web browsers where you can view messages, run JavaScript, and debug your website. It helps you interact with and test your web page directly while it's open in the browser.

-An operating system is the software that controls and manages the hardware of a computer, enabling other programs to run and helping users interact with the computer.

-Formatting makes your code neat and consistent.
Linting checks your code for errors and bad practices.
Automatic Syntax Highlighting colors your code to make it easier to read and understand.

-Modern JavaScript (ES6+) brings powerful features to make JavaScript easier to write and more efficient, including new syntax, async handling, and tools for better code structure.
Node.js allows you to run JavaScript on the server side, enabling you to build backend applications, APIs, and handle many tasks simultaneously with its non-blocking design

-JavaScript runs in the browser using the browser’s JavaScript engine. It allows developers to make web pages interactive, update content dynamically, and respond to user actions, all without needing to reload the page.

-"Top to bottom" in JavaScript means that the code is executed from the first line to the last line in a sequential order, unless interrupted by other structures like functions, loops, or asynchronous tasks.

-Hoisting: Think of it as moving declarations to the top of the code.
Scoping: Think of it as rules for where variables can be used.

-Function Scope: Variables with var work throughout the entire function.
Block Scope: Variables with let or const work only inside the specific block where they are declared.
-You can use let or const in a function.
However, they still follow block scope rules. If you use them inside a block (like an if or for), they will only be accessible within that block. If they’re not inside a block, they will behave like they have function scope.

-All variables (var, let, const) are hoisted.
var: Hoisted and initialized as undefined. Can be used before the declaration (but shows undefined).
let and const: Hoisted but not initialized. Trying to use them before the declaration throws a ReferenceError.

-Declaration = "I need a box!"
Initialization = "Here’s what goes in the box!"

-useContext(AuthContext)?

It lets us access the shared authentication data stored in AuthContext.

-useAuth a function?

To save time and make the app easier to read.
It’s easier to call useAuth() than to write useContext(AuthContext) everywhere.

-export const?

export lets other files use this function.
const ensures the function doesn’t accidentally change.

-createContext(): Creates the treasure chest (empty at first).
-AuthContext: The chest that holds authentication data.
-AuthProvider: The helper that wraps the app and shares the chest with all child components.
-useState: Keeps track of what’s in the chest (e.g., token) and allows changes.
-Now, different parts of the app can easily use the chest, like:

Showing the user’s name if they’re logged in.
Redirecting them to the login page if they’re not.


